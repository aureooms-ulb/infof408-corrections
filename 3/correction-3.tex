\documentclass{article}
\errorcontextlines 10000

\makeatletter

\usepackage{fontspec}
\usepackage{xunicode}
\usepackage{xltxtra}

\usepackage{fullpage}
\usepackage{mleftright}

\usepackage{hyperref}

\hypersetup{%
	linktocpage  = true, %page number is the link (not title)
	colorlinks   = true, %Colours links instead of ugly boxes
	urlcolor     = darkblue, %Colour for external hyperlinks
	linkcolor    = darkblue, %Colour of internal links
	citecolor    = darkblue   %Colour of citations
}

%\hypersetup{
%	linktocpage  = true, %page number is the link (not title)
%	colorlinks   = true, %Colours links instead of ugly boxes
%	allcolors = bookColor,
%	hidelinks = true
%}

% good looking urls
\urlstyle{same}

\newcommand{\theoremname}{Theorem}
\newcommand{\problemname}{Problem}
\newcommand{\conjecturename}{Conjecture}

% we use this for our references as well
\let\sref\ref
\AtBeginDocument{\renewcommand{\ref}[1]{\mbox{\autoref{#1}}}}
\usepackage[nameinlink]{cleveref}

% define colors %
\usepackage[table]{xcolor}

%\usepackage[table,dvipdfx,cmyk]{xcolor}
%\definecolor{bookColor}{cmyk}{0 ,0 ,0 ,1}
%\color{bookColor}

\definecolor{lightgray}{rgb}{0.9,0.9,0.9}
\definecolor{darkgray}{rgb}{0.4,0.4,0.4}
\definecolor{purple}{rgb}{0.65, 0.12, 0.82}
\definecolor{darkblue}{rgb}{0.02, 0.17, 0.40}
\usepackage[stable]{footmisc}
\usepackage{graphicx}
\usepackage{caption}
\usepackage{subcaption}
\usepackage{tikz}
\usepackage{url}
\usepackage{amsmath,amsthm,amsfonts}
\newtheorem{theorem}{\theoremname}
\newtheorem{problem}{\problemname}
\newtheorem{conjecture}{\conjecturename}

% nicely spaced operators
\DeclareMathOperator{\Exists}{\exists}
\DeclareMathOperator{\Forall}{\forall}

\newcommand{\st}{\colon\,}
\newcommand{\TM}{TM}
\newcommand{\Atm}{A\textsubscript{TM}}
\newcommand{\HALTtm}{HALT\textsubscript{TM}}

\newcommand\N{\mathbb{N}_1}

\newcommand*\circled[1]{\tikz[baseline=(char.base)]{
            \node[shape=circle,draw,inner sep=2pt] (char) {#1};}}



% TURING MACHINE DESCRIPTIONS
\usepackage{changepage}
\newenvironment{steps}%
{%
\vspace{0.25cm}%
\begin{adjustwidth}{0.3cm}{0cm}%
\begin{description}%
}
{%
\end{description}%
\end{adjustwidth}%
\vspace{0.1cm}%
}

\newcounter{TMachine}[section]
\renewcommand{\theTMachine}{\thesection.\arabic{TMachine}}%
\newenvironment{TMachine}[1]
  {\refstepcounter{TMachine}%
   \par%
   \vspace{.5\baselineskip\@plus.2\baselineskip\@minus.2\baselineskip}% Space above
   \noindent{#1}%
   \begin{steps}}%\begin{TMachine}
  {\end{steps}%
\vspace{.5\baselineskip\@plus.2\baselineskip\@minus.2\baselineskip}% Space below
}% \end{TMachine}

\newcommand{\accept}{\emph{accept}}
\newcommand{\reject}{\emph{reject}}

\makeatother

\title{Computability and Complexity:\\Exercise Session 3 (2015-10-09)}
\author{Aur√©lien Ooms\footnote{aureooms@ulb.ac.be}}
\date{\today}

\begin{document}
\maketitle
\tableofcontents

\section{Exercise 5.19\footnote{Exercises from the reference book: Sipser M.,
\emph{Introduction to the Theory of Computation}, 3rd edition (2013).}}

Remember the definition of Post's correspondence problem
\begin{problem}\label{PCP}
	Given a finite set of \(n\) dominos\footnote{\([n] = \{1,2,\ldots,n\}\)}
	\(P = \mleft\{ \mleft[\frac{t_1}{b_1}\mright] , \mleft[\frac{t_2}{b_2}\mright] , \ldots
			, \mleft[\frac{t_n}{b_n}\mright]\mright\}\), such that \(t_i, b_i
		\in \Sigma^*\)
			for all \(i \in [n]\), decide
	whether there exists a \(k\)-tuple of indices \((i_1,i_2,\ldots,i_k)\),
	called a match,
	such that\footnote{\(v = v_1 v_2 \ldots v_{n_v} \in \Sigma^* \land w = w_1 w_2 \ldots
			w_{n_w} \in \Sigma^* \implies v \circ w = v_1 v_2 \ldots v_{n_v} w_1 w_2
	\ldots w_{n_w}\) }
	\(t_{i_1} \circ t_{i_2} \circ \cdots \circ t_{i_k} =
	b_{i_1} \circ b_{i_2} \circ \cdots \circ b_{i_k} \).
\end{problem}

In the \emph{silly Post Correspondence Problem, SPCP}, the top string \(t_i\)
in each pair has the same length has the bottom string \(b_i\). We can decide
this problem using the following observation.
A match for a set of dominos \(P\) can only start with a domino whose top
string has as a prefix the bottom string or vice versa. If such a domino does
not exist then there is simply no way one can build a match.
For the SPCP, we thus have two cases:
\begin{enumerate}
	\item Either there is no such domino, and there is no match.
	\item Or this domino exists and then a match can be this single domino
		since without loss of generality the bottom string is a prefix of the
		top string and both strings have the same length. Hence, they must be
		equal.
\end{enumerate}
Note that you can build a TM that decides the problem by checking that \(P\)
contains such a domino in finite time.

\section{Exercise 5.17}
We consider \ref{PCP} again, this time adding the constraint that the alphabet
is unary, for example \(\Sigma = \{1\}\). Note that in this case, you can always start a
match since all dominos are of the form\footnote{\(1^n = \underbrace{11\ldots1}_{n \text{ times}}\)}
\(\mleft[\frac{1^m}{1^n}\mright]\)
and hence for each domino either the bottom string is a prefix of the top
string or the top string is a prefix of the bottom string, or both.
For each domino \(d\) of the form \(\mleft[\frac{1^m}{1^n}\mright]\) let us
define \(\Delta(d) = m - n\). Since there is only one symbol,
we only need to match the lengths of the
top and bottom part of a match, and hence a \(k\)-tuple \(M = (i_1,i_2,\ldots,i_k)\)
is a match if and only if \(\sum_{i \in M}
	\Delta(\mleft[\frac{t_i}{b_i}\mright]) = 0\).
To solve this problem, we have to handle four cases:
\begin{enumerate}
	\item If \(P\) contains a domino \(d=\mleft[\frac{1^m}{1^n}\mright]\) such that
		\(m=n\), that is \(\Delta(d) = 0\) then we have a match consisting of this single domino.
	\item If each domino \(d \in P\) is such that \(\Delta(d) < 0\) then there
		is no way we can find a match.
	\item Symmetrically, if each domino \(d \in P\) is such that \(\Delta(d) > 0\) then there
		is no way we can find a match.
	\item If for \(\Delta_i, \Delta_j > 0\) there are \(d_i,d_j \in P\) such
		that \(\Delta(d_i) = -\Delta_i\) and \(\Delta(d_j) = +\Delta_j\) then a
		match can be found by computing the lowest common multiple of
		\(\Delta_i\) and \(\Delta_j\). Let \(c_i =
			\frac{\mathop{lcm}(\Delta_i,\Delta_j)}{\Delta_i}\) and \(c_j =
			\frac{\mathop{lcm}(\Delta_i,\Delta_j)}{\Delta_j}\) then a valid
			match is \(M = (\underbrace{i i \ldots i}_{c_i \text{
							times}},\underbrace{j j \ldots j}_{c_j
			\text{ times}})\) since then \(\sum_{k \in M}
	\Delta(d_k) = c_i \Delta_i - c_j \Delta_j
= \frac{\mathop{lcm}(\Delta_i,\Delta_j)}{\Delta_i} \Delta_i -
\frac{\mathop{lcm}(\Delta_i,\Delta_j)}{\Delta_j} \Delta_j
=\mathop{lcm}(\Delta_i,\Delta_j) - \mathop{lcm}(\Delta_i,\Delta_j)
= 0\).
\end{enumerate}
Note that you can build a TM that decides the problem by checking for all those
cases in finite time.

\section{Exercise 5.9}

We showed during last lecture (2015-10-05) that given some non-trivial property
\(P\) the problem of deciding whether the language \(L(M)\) of some TM \(M\)
has property \(P\), that is, \(L(M) \in P\), is undecidable. This result is
Rice's theorem. To solve this exercise, we just have to show
that\footnote{\(w = w_1 w_2 \ldots w_n \iff w^{\mathcal{R}} = w_{n} w_{n-1}\ldots w_{1}\)}
\(P = \{A \st w \in A \iff
w^{\mathcal{R}} \in A \}\) is indeed a non-trivial\footnote{Non-trivial means
that \(P \neq \emptyset \land P \neq \mathcal{P}(\Sigma^*)\), where
\(\mathcal{P}(S)\) is the set of all subsets of \(S\). \(\mathcal{P}\) is
called the powerset operator.} property. For
example, \(\{\texttt{01}\} \not\in P\) so \(P \neq \mathcal{P}(\Sigma^*)\) and
\(\{\texttt{1}\} \in P\) so \(P \neq \emptyset\).

Alternatively, we can produce the following proof reducing \Atm{} to our problem.
Let us assume \(T = \{\langle M \rangle \st M \text{ is a \TM{} that accepts
\(w^{\mathcal{R}}\) whenever it accepts \(w\)}\}\) is decidable. That means
there exists a decider \(H\) for language \(T\). Given some input \(\langle
M,w\rangle\) to test against the language \Atm{}, build the following
\TM{}:

\begin{TMachine}{\(D_{\langle M,w\rangle} =\) on input \(x\):}
\item[1.] If \(x = \texttt{01}\): \accept.
\item[2.] Otherwise run \(M\) on \(w\). If \(M\) accepts, \accept. Otherwise
		\reject.
\end{TMachine}
Note that \(L(D) = \Sigma^* \in P\) if and only if \(M\) accepts \(w\) and
\(L(D) = \{\texttt{01}\} \not\in P\) if and only if \(M\) does not accept
\(w\). Hence, for any input \(\langle M,w\rangle\) we can decide whether \(M\)
accepts \(w\) by running the decider \(H\) on \(\langle D_{\langle M,w\rangle}
\rangle\), a contradiction with respect to the theorem about the undecidability
of \Atm{} we proved during the lectures.

\section{Exercise 5.31}
We are given the following conjecture
\begin{conjecture}[Collatz's conjecture]\label{collatz}
	Let\footnote{\(\N = \{1,2,\ldots\}\), that is, the set of all natural
		numbers except \(0\).}
\begin{displaymath}
f:\N \to \N:f(x) = \begin{cases}
	3 x + 1 & \text{if \(x\) is odd}\\
	x / 2 & \text{if \(x\) is even}.
\end{cases}
\end{displaymath}
For all \(x \in \N\) the set \(\{x,f(x),f(f(x)),\ldots\}\) contains \(1\).
\end{conjecture}
A conjecture is a statement
for which we do not have a proof that it holds or does not hold.
We want to show that if there existed a decider \(H\) for \Atm{}
then we could build a
\TM{} that would compute a proof of~\ref{collatz} for us.

First, let us define \TM{} \(C\) that recognizes
the subset of \(\N\)
for which the conjecture holds, that is, \(\{x \in \N \st 1 \in
\{x,f(x),f(f(x)),\ldots\} \}\).

\begin{TMachine}{\(C =\) on input \(\langle x \rangle\):}
\item[1.] While \(x \neq 1\): \(x \gets f(x)\)
\item[2.] \(1 \in \{x,f(x),f(f(x)),\ldots\}\) so \accept.
\end{TMachine}

To be able to easily combine\footnote{Alternatively, one can use a mapping from
\(\Sigma\) to \(\N\).} this \TM{} with others, we will define
a \TM{} \(C_{\Sigma^*}\) so that~\ref{collatz} holds if and only if
\(L(C_{\Sigma^*}) =
		\Sigma^*\). Here we take \(\Sigma = \{0,1\}\), the binary alphabet.

\begin{TMachine}{\(C_{\Sigma^*} =\) on input \(w\):}
\item[1.] If\footnote{This can be checked in a finite amount of time.} \(w \not\in
\{\texttt{1},\texttt{10},\texttt{11},\texttt{100},\texttt{101},\texttt{110},\texttt{111},\ldots\}\),
that is, \(w\) is not\footnote{For example, \(w
	= \epsilon\).} the binary representation \(\langle x \rangle\)
		of a number \(x \in \N\), \accept.
	\item[2.] While \(x \neq 1\): \(x \gets f(x)\)
	\item[3.] \(1 \in \{x,f(x),f(f(x)),\ldots\}\) so \accept.
\end{TMachine}

Using \(H\) we build \(R_{\neq \Sigma^*}\), a recognizer for the language
\(L(R_{\neq \Sigma^*}) = \{\langle M\rangle\st L(M) \neq \Sigma^*\}\).

\begin{TMachine}{\(R_{\neq \Sigma^*} =\) on input \(\langle M \rangle\):}
	\item[1.] For each \(w \in \Sigma^*\) in lexicographic order:
	\item[1.1.] Run \(H\) on \(\langle M , w \rangle\).
	\item[1.2.] If \(H\) rejects, \accept.
\end{TMachine}

Finally, we run \(H\) on \(\langle R_{\neq \Sigma^*}, \langle C_{\Sigma^*} \rangle
		\rangle\) to check whether~\ref{collatz} holds. If \(H\) rejects then
		\(L(C_{\Sigma^*}) = \Sigma^*\) and hence the conjecture holds, otherwise the
		conjecture does not hold.

\end{document}
