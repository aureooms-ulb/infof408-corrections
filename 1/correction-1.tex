\documentclass{article}
\errorcontextlines 10000

\makeatletter
\usepackage{fontspec}
\usepackage{xunicode}
\usepackage{xltxtra}

\usepackage{fullpage}

\usepackage{hyperref}

\hypersetup{
	linktocpage  = true, %page number is the link (not title)
	colorlinks   = true, %Colours links instead of ugly boxes
	urlcolor     = darkblue, %Colour for external hyperlinks
	linkcolor    = darkblue, %Colour of internal links
	citecolor    = darkblue   %Colour of citations
}

%\hypersetup{
%	linktocpage  = true, %page number is the link (not title)
%	colorlinks   = true, %Colours links instead of ugly boxes
%	allcolors = bookColor,
%	hidelinks = true
%}

% good looking urls
\urlstyle{same}

% we use this for our references as well
\let\sref\ref
\AtBeginDocument{\renewcommand{\ref}[1]{\mbox{\autoref{#1}}}}
\usepackage[nameinlink]{cleveref}

% define colors %
\usepackage[table]{xcolor}

%\usepackage[table,dvipdfx,cmyk]{xcolor}
%\definecolor{bookColor}{cmyk}{0 ,0 ,0 ,1}
%\color{bookColor}

\definecolor{lightgray}{rgb}{.9,.9,.9}
\definecolor{darkgray}{rgb}{.4,.4,.4}
\definecolor{purple}{rgb}{0.65, 0.12, 0.82}
\definecolor{darkblue}{rgb}{0.02, 0.17, 0.40}
\usepackage[stable]{footmisc}
\usepackage{graphicx}
\usepackage{caption}
\usepackage{subcaption}
\usepackage{tikz}
\usepackage{url}
\usepackage{amsmath}
\usepackage{stackengine,scalerel}
\renewcommand\useanchorwidth{T}
\newcommand\obullet[1]{\ThisStyle{\ensurestackMath{%
  \stackon[1pt]{\SavedStyle#1}{\SavedStyle\kern.6\LMpt\bullet}}}}
\newcommand\ocirc[1]{\ThisStyle{\ensurestackMath{%
  \stackon[1pt]{\SavedStyle#1}{\SavedStyle\kern.6\LMpt\circ}}}}

\newcommand{\0}{\texttt{\textvisiblespace}}
\newcommand{\°}{\obullet{\0}}
\newcommand{\BB}{\obullet{\0^*}}
\newcommand{\A}{\obullet{\s}}
\newcommand{\Q}{\obullet{\texttt{b}}}
\newcommand{\HA}{\obullet{\s^*}}
\newcommand{\HQ}{\obullet{\texttt{b}^*}}
\newcommand{\s}{\texttt{a}}
\newcommand{\X}{\texttt{x}}
\newcommand{\e}{\texttt{\#}}
\newcommand{\st}{\colon\,}
\newcommand{\TM}{TM}

% TURING MACHINE DESCRIPTIONS
\usepackage{changepage}
\newenvironment{steps}%
{%
\vspace{0.25cm}%
\begin{adjustwidth}{0.3cm}{0cm}%
\begin{description}%
}
{%
\end{description}%
\end{adjustwidth}%
\vspace{0.1cm}%
}

\newcounter{TMachine}[section]
\renewcommand{\theTMachine}{\thesection.\arabic{TMachine}}%
\newenvironment{TMachine}[1]
  {\refstepcounter{TMachine}%
   \par%
   \vspace{.5\baselineskip\@plus.2\baselineskip\@minus.2\baselineskip}% Space above
   \noindent{#1}%
   \begin{steps}}%\begin{TMachine}
  {\end{steps}%
\vspace{.5\baselineskip\@plus.2\baselineskip\@minus.2\baselineskip}% Space below
}% \end{TMachine}

\newcommand{\accept}{\emph{accept}}
\newcommand{\reject}{\emph{reject}}
\makeatother

\title{Computability and Complexity:\\Exercise Session 1 (2015-09-25)}
\author{Aurélien Ooms\footnote{aureooms@ulb.ac.be}}
\date{\today}

\begin{document}
\maketitle
\tableofcontents

\section{Exercise 3.10\footnote{Exercises from the reference book: Sipser M.,
\emph{Introduction to the Theory of Computation}, 3rd edition (2013).}}

\subsection{Introductory remarks}
In the standard definition of the Turing machine (\TM{}), each step writes a symbol to
the cell pointed by the head. Here, we consider that writing the same symbol as
the one that is already in this cell does not count as ``writing''. We
interpret ``writing to a cell'' as altering the content of the cell
(see~\ref{writing}).
\begin{figure}
    \centering
    \begin{subfigure}{0.4\textwidth}
        \centering
		\begin{tikzpicture}[scale=.5]
			\draw[->] (3,3.25) -- (3,2.75) ;
			\draw[->] (4,1.25) -- (4,.75) ;

			\foreach \y/\v in {2/{1/0,2/1,3/1,4/0,5/1},0/{1/0,2/1,3/0,4/0,5/1}}
			\foreach \x/\k in \v {
				\draw (\x,\y) +(-.5,-.5) rectangle ++(.5,.5);
				\draw (\x,\y) node{$\k$};
			}

			\draw[dotted] (5.5,2.5) -- (6,2.5);
			\draw[dotted] (5.5,1.5) -- (6,1.5);
			\draw[dotted] (5.5,.5) -- (6,.5);
			\draw[dotted] (5.5,-.5) -- (6,-.5);

			\draw (.5,2) node[anchor=east]{before} ;
			\draw (.5,0) node[anchor=east]{after} ;

		\end{tikzpicture}
        \caption{Altering a cell, \(\delta(q_i,1) = (q_j,0,R)\). Counting as one write operation.}
    \end{subfigure}%
    ~
    \begin{subfigure}{0.4\textwidth}
        \centering
		\begin{tikzpicture}[scale=.5]
			\draw[->] (3,3.25) -- (3,2.75) ;
			\draw[->] (4,1.25) -- (4,.75) ;

			\foreach \y/\v in {2/{1/0,2/1,3/1,4/0,5/1},0/{1/0,2/1,3/1,4/0,5/1}}
			\foreach \x/\k in \v {
				\draw (\x,\y) +(-.5,-.5) rectangle ++(.5,.5);
				\draw (\x,\y) node{$\k$};
			}

			\draw[dotted] (5.5,2.5) -- (6,2.5);
			\draw[dotted] (5.5,1.5) -- (6,1.5);
			\draw[dotted] (5.5,.5) -- (6,.5);
			\draw[dotted] (5.5,-.5) -- (6,-.5);

			\draw (.5,2) node[anchor=east]{before} ;
			\draw (.5,0) node[anchor=east]{after} ;

		\end{tikzpicture}
		\caption{Keeping the cell as is, \(\delta(q_i,1) = (q_j,1,R)\). Counting as zero write operations.}
    \end{subfigure}
	\caption{Counting write operations.}
	\label{writing}
\end{figure}

At the beginning of the execution of the \TM{}, the input is
present on the tape and this counts as zero write operations.

If some set/combinations/thing is of finite size and does not depend on the input
we can encode all its different ``elements'' in the states of the \TM{}.

We call the simulated \TM{} (the one we want to simulate) \(M\) and we
call the simulation \TM{} (the one used to simulate \(M\)) \(S\).

When we say that we add new symbols (\X{}, \e{}) we suppose they
are not already part of some used alphabet and this is without loss of
generality.
Similarily, we make the blank symbol of the simulated \TM{} and the
simulation \TM{} different. The blank symbol of \(M\)
is \°{} while the blank symbol of \(S\)
is \0{}. In general you can consider that the tape alphabet of \(M\)
does not include any of the symbols we will add to make \(S\) work.
For example, we can use one color for the tape alphabet of \(M\) and
another color for symbols we add. Here we will consider that all symbols used
by \(M\) are dotted (like \°{}) while the symbols that
have a special meaning for \(S\) are not (like \0{}).

\subsection{Using two writes per cell}
The idea is to simulate each step of the simulated
\TM{} by copying all ``working'' cells to new (unused) cells
while applying the transition function to the cell pointed by the head.

We use a copy procedure that copies each character after
the other by doing ``zig-zags'' between the cells to be copied and the destination
cells. In order to remember which cells were already copied we cross those
cells off during the procedure.

We implement the cross off operation as
writing a special character (for example, \X{}) in the concerned cell.
This operation counts thus as one write operation. The cost of writing the
symbol of the copied cell to the destination also counts as a write. A cell
will thus be written to at most twice (once when copied to, and then
once when crossed off).

In order to detect when the copy procedure has copied all cells,
we add\footnote{%
This fixes some confusion/comprehension issue we had when designing the
write-once machine. Relying on the presence of blank symbols as I explained
during the exercise session was not easily comprehensible without all the
explanation I give here.}
a special character (for example, \e)
at the end of the currently used portion of the tape.
We thus add this special symbol directly to the right of the last cell being written to by the
copy procedure (and also at the end of the input before beginning the
simulation). The cells containing this special character will only be written to once.
This is handled by steps 7 and 8 in \ref{copying:last}.

Here are the detailed steps to copy a symbol \obullet{\s}:
\begin{enumerate}
	\item Cross off \obullet{\s} by writing a \X{}. This
		counts as a single write operation.
	\item Enter a state that remembers that we need to copy symbol
		\obullet{\s}, for example, \((q_{\texttt{a}}^1)\). We are allowed
		to do this since the alphabet of M is a finite set (and its size does not
		depend on the input).
	\item While in state \((q_{\texttt{a}}^1)\), move right (without
		altering the current cell) until we reach
		the symbol \e, change then to state
		\((q_{\texttt{a}}^2)\).
	\item While in state \((q_{\texttt{a}}^2)\), move right (without
	altering the current cell) until we reach the symbol \0{}.
\item Replace the \0{} by \obullet{\s} using a
		single write operation and enter state \((q_{\texttt{a}}^3)\).
	\item While in state \((q_{\texttt{a}}^3)\), move left until we reach
		the symbol \X{}, enter state \((q_{\texttt{a}}^0)\)
		then move right.
\end{enumerate}
A copy of all the cells can be achieved by entering state \((q_{\texttt{a}}^0)\)
then apply the procedure above repeatedly.
The copy stops when in state \((q_{\texttt{a}}^0)\) we read a \e{}
symbol (see~\ref{copying}).
\begin{figure}
    \centering
    \begin{subfigure}{0.4\textwidth}
        \centering
		\begin{tikzpicture}[scale=.5]
			\draw[->] (1,3.25) ++(0, 0)-- +(0,-.5) ;
			\draw[->] (1,3.25) ++(0,-2) -- +(0,-.5) ;
			\draw[->] (6,3.25) ++(0,-4) -- +(0,-.5) ;
			\draw[->] (7,3.25) ++(0,-6) -- +(0,-.5) ;
			\draw[->] (7,3.25) ++(0,-8) -- +(0,-.5) ;
			\draw[->] (2,3.25) ++(0,-10) -- +(0,-.5) ;

			\foreach \y/\v in {%
				2/{1/\Q,2/\A,3/\A,4/\Q,5/\A,6/\e,7/\0,8/\0,9/\0,10/\0,11/\0,12/\0},%
				0/{1/\X,2/\A,3/\A,4/\Q,5/\A,6/\e,7/\0,8/\0,9/\0,10/\0,11/\0,12/\0},%
				-2/{1/\X,2/\A,3/\A,4/\Q,5/\A,6/\e,7/\0,8/\0,9/\0,10/\0,11/\0,12/\0},%
				-4/{1/\X,2/\A,3/\A,4/\Q,5/\A,6/\e,7/\0,8/\0,9/\0,10/\0,11/\0,12/\0},%
				-6/{1/\X,2/\A,3/\A,4/\Q,5/\A,6/\e,7/\Q,8/\0,9/\0,10/\0,11/\0,12/\0},%
				-8/{1/\X,2/\A,3/\A,4/\Q,5/\A,6/\e,7/\Q,8/\0,9/\0,10/\0,11/\0,12/\0},%
			}{
				\draw[dotted] (12.5,\y) +(0,0.5)-- +(.5,0.5);
				\draw[dotted] (12.5,\y) +(0,-.5)-- +(.5,-.5);
				\foreach \x/\k in \v {
					\draw (\x,\y) +(-.5,-.5) rectangle ++(.5,.5);
					\draw (\x,\y) node{$\k$};
				}
			}

			\draw (.5,2) node[anchor=east]{1.} ;
			\draw (.5,0) node[anchor=east]{2.} ;
			\draw (.5,-2) node[anchor=east]{3.} ;
			\draw (.5,-4) node[anchor=east]{4.} ;
			\draw (.5,-6) node[anchor=east]{5.} ;
			\draw (.5,-8) node[anchor=east]{6.} ;

		\end{tikzpicture}
	\caption{Copying the first cell.}
    \end{subfigure}%
	~
    \begin{subfigure}{0.4\textwidth}
        \centering
		\begin{tikzpicture}[scale=.5]
			\draw[->] (5,3.25) ++(0, 0)-- +(0,-.5) ;
			\draw[->] (5,3.25) ++(0,-2) -- +(0,-.5) ;
			\draw[->] (6,3.25) ++(0,-4) -- +(0,-.5) ;
			\draw[->] (11,3.25) ++(0,-6) -- +(0,-.5) ;
			\draw[->] (11,3.25) ++(0,-8) -- +(0,-.5) ;
			\draw[->] (6,3.25) ++(0,-10) -- +(0,-.5) ;
			\draw[->] (12,3.25) ++(0,-12) -- +(0,-.5) ;
			\draw[->] (12,3.25) ++(0,-14) -- +(0,-.5) ;
			\draw[->] (7,3.25) ++(0,-16) -- +(0,-.5) ;

			\foreach \y/\v in {%
				2/{1/\X,2/\X,3/\X,4/\X,5/\A,6/\e,7/\Q,8/\A,9/\A,10/\Q,11/\0,12/\0},%
				0/{1/\X,2/\X,3/\X,4/\X,5/\X,6/\e,7/\Q,8/\A,9/\A,10/\Q,11/\0,12/\0},%
				-2/{1/\X,2/\X,3/\X,4/\X,5/\X,6/\e,7/\Q,8/\A,9/\A,10/\Q,11/\0,12/\0},%
				-4/{1/\X,2/\X,3/\X,4/\X,5/\X,6/\e,7/\Q,8/\A,9/\A,10/\Q,11/\0,12/\0},%
				-6/{1/\X,2/\X,3/\X,4/\X,5/\X,6/\e,7/\Q,8/\A,9/\A,10/\Q,11/\A,12/\0},%
				-8/{1/\X,2/\X,3/\X,4/\X,5/\X,6/\e,7/\Q,8/\A,9/\A,10/\Q,11/\A,12/\0},%
				-10/{1/\X,2/\X,3/\X,4/\X,5/\X,6/\e,7/\Q,8/\A,9/\A,10/\Q,11/\A,12/\0},%
				-12/{1/\X,2/\X,3/\X,4/\X,5/\X,6/\e,7/\Q,8/\A,9/\A,10/\Q,11/\A,12/\e},%
				-14/{1/\X,2/\X,3/\X,4/\X,5/\X,6/\e,7/\Q,8/\A,9/\A,10/\Q,11/\A,12/\e},%
			}{
				\draw[dotted] (12.5,\y) +(0,0.5)-- +(.5,0.5);
				\draw[dotted] (12.5,\y) +(0,-.5)-- +(.5,-.5);
				\foreach \x/\k in \v {
					\draw (\x,\y) +(-.5,-.5) rectangle ++(.5,.5);
					\draw (\x,\y) node{$\k$};
				}
			}

			\draw (.5,2) node[anchor=east]{1.} ;
			\draw (.5,0) node[anchor=east]{2.} ;
			\draw (.5,-2) node[anchor=east]{3.} ;
			\draw (.5,-4) node[anchor=east]{4.} ;
			\draw (.5,-6) node[anchor=east]{5.} ;
			\draw (.5,-8) node[anchor=east]{6.} ;
			\draw (.5,-10) node[anchor=east]{7.} ;
			\draw (.5,-12) node[anchor=east]{8.} ;
			\draw (.5,-14) node[anchor=east]{9.} ;

		\end{tikzpicture}
	\caption{Copying the last cell.}
	\label{copying:last}
    \end{subfigure}
	\caption{Copying working cells.}
	\label{copying}
\end{figure}

We still need to describe how we can simulate \(M\), that is, remember the
position of the head, update the cell pointed by the head and move the head
according to the transition function of \(M\).

To remember the position of the head of the simulated \TM{} we use
colored symbols (in addition to the color used to differentiate the symbols
used by \(M\) from the symbols having a special meaning for \(S\),
see~\ref{head}).
\begin{figure}
	\centering
	\begin{tikzpicture}[scale=.5]
		\draw[->] (1,3.25) -- (1,2.75) ;

		\foreach \y/\v in {2/{1/\Q,2/\HA,3/\Q,4/\Q,5/\A,6/\e}}
		\foreach \x/\k in \v {
			\draw (\x,\y) +(-.5,-.5) rectangle ++(.5,.5);
			\draw (\x,\y) node{$\k$};
		}

		\draw[dotted] (0.5,2.5) -- (0,2.5);
		\draw[dotted] (0.5,1.5) -- (0,1.5);
		\draw[dotted] (6.5,2.5) -- (7,2.5);
		\draw[dotted] (6.5,1.5) -- (7,1.5);

	\end{tikzpicture}
	\caption{The first cell is pointed by the head of \(S\) (the arrow).
	The second cell is pointed by the head of \(M\) (the starred symbol).}
	\label{head}
\end{figure}
We do not need to color the first cell at the beginning of
the simulation since we ``know'' the first cell is pointed by the head at the
beginning. Again we can handle this using states since there is a finite number
of possibilities. A simple way to do this is to use special states for the
first steps of \(S\) that will allow us to copy the input with the
appropriate symbols/marks/colors added.

Before copying a cell we need to check whether the next one is the head (is a
colored symbol).
In that case, we have two possibilities (see \ref{transition}):
\begin{enumerate}
\item If the transition function makes the head move left, then
we copy the current cell (the cell to the left of the
head) using the colored version of the symbol, write the symbol designated by
the transition function to the destination cell for the
cell pointed by the head, and then copy the cell to the right of the head
using the normal copy procedure.
\item If the transition function makes the head move right, then
we copy the current cell (the cell to the left of the
head) using the normal copy procedure, write the symbol designated by
the transition function to the destination cell for the
cell pointed by the head, and then copy the cell to the right of the head
using the colored version of the symbol.
\end{enumerate}
\begin{figure}
    \centering
    \begin{subfigure}{0.4\textwidth}
        \centering
		\begin{tikzpicture}[scale=.5]
			\draw[->] (2,3.25) ++(0, 0)-- +(0,-.5) ;
			\draw[->] (5,3.25) ++(0,-2) -- +(0,-.5) ;

			\foreach \y/\v in {%
				2/{1/\X,2/\Q,3/\HA,4/\A,5/\A,6/\e,7/\A,8/\0,9/\0,10/\0,11/\0,12/\0},%
				0/{1/\X,2/\X,3/\X,4/\X,5/\A,6/\e,7/\A,8/\HQ,9/\Q,10/\A,11/\0,12/\0},%
			}{
				\draw[dotted] (12.5,\y) +(0,0.5)-- +(.5,0.5);
				\draw[dotted] (12.5,\y) +(0,-.5)-- +(.5,-.5);
				\foreach \x/\k in \v {
					\draw (\x,\y) +(-.5,-.5) rectangle ++(.5,.5);
					\draw (\x,\y) node{$\k$};
				}
			}

			\draw (.5,2) node[anchor=east]{1.} ;
			\draw (.5,0) node[anchor=east]{2.} ;

		\end{tikzpicture}
		\caption{\(\delta(q_i,a) = (q_j,b,L)\), that is, moving left.}
    \end{subfigure}%
	~
    \begin{subfigure}{0.4\textwidth}
        \centering
		\begin{tikzpicture}[scale=.5]
			\draw[->] (2,3.25) ++(0, 0)-- +(0,-.5) ;
			\draw[->] (5,3.25) ++(0,-2) -- +(0,-.5) ;

			\foreach \y/\v in {%
				2/{1/\X,2/\Q,3/\HA,4/\A,5/\A,6/\e,7/\A,8/\0,9/\0,10/\0,11/\0,12/\0},%
				0/{1/\X,2/\X,3/\X,4/\X,5/\A,6/\e,7/\A,8/\Q,9/\Q,10/\HA,11/\0,12/\0},%
			}{
				\draw[dotted] (12.5,\y) +(0,0.5)-- +(.5,0.5);
				\draw[dotted] (12.5,\y) +(0,-.5)-- +(.5,-.5);
				\foreach \x/\k in \v {
					\draw (\x,\y) +(-.5,-.5) rectangle ++(.5,.5);
					\draw (\x,\y) node{$\k$};
				}
			}

			\draw (.5,2) node[anchor=east]{1.} ;
			\draw (.5,0) node[anchor=east]{2.} ;

		\end{tikzpicture}
		\caption{\(\delta(q_i,a) = (q_j,b,R)\), that is, moving right.}
    \end{subfigure}%
	\caption{Handling the transition function.}
	\label{transition}
\end{figure}

We also need to handle two special cases.
\begin{figure}
    \centering
    \begin{subfigure}{0.4\textwidth}
        \centering
		\begin{tikzpicture}[scale=.5]
			\draw[->] (2,3.25) ++(0, 0)-- +(0,-.5) ;
			\draw[->] (3,3.25) ++(0,-2) -- +(0,-.5) ;

			\foreach \y/\v in {%
				2/{1/\e,2/\HA,3/\A,4/\A,5/\A,6/\e,7/\0,8/\0,9/\0,10/\0,11/\0,12/\0},%
				0/{1/\e,2/\X,3/\A,4/\A,5/\A,6/\e,7/\HQ,8/\0,9/\0,10/\0,11/\0,12/\0},%
			}{
				\draw[dotted] (12.5,\y) +(0,0.5)-- +(.5,0.5);
				\draw[dotted] (12.5,\y) +(0,-.5)-- +(.5,-.5);
				\draw[dotted] (.5,\y) +(0,0.5)-- +(.5,0.5);
				\draw[dotted] (.5,\y) +(0,-.5)-- +(.5,-.5);
				\foreach \x/\k in \v {
					\draw (\x,\y) +(-.5,-.5) rectangle ++(.5,.5);
					\draw (\x,\y) node{$\k$};
				}
			}

			\draw (.5,2) node[anchor=east]{1.} ;
			\draw (.5,0) node[anchor=east]{2.} ;

		\end{tikzpicture}
		\caption{\(\delta(q_i,a) = (q_j,b,L)\), that is, moving left on the
		leftmost cell.}
		\label{transition:leftmost}
    \end{subfigure}%
	~
    \begin{subfigure}{0.4\textwidth}
        \centering
		\begin{tikzpicture}[scale=.5]
			\draw[->] (4,3.25) ++(0, 0)-- +(0,-.5) ;
			\draw[->] (7,3.25) ++(0,-2) -- +(0,-.5) ;

			\foreach \y/\v in {%
				2/{1/\e,2/\X,3/\X,4/\A,5/\HA,6/\e,7/\A,8/\Q,9/\0,10/\0,11/\0,12/\0},%
				0/{1/\e,2/\X,3/\X,4/\X,5/\X,6/\e,7/\A,8/\Q,9/\A,10/\Q,11/\BB,12/\e},%
			}{
				\draw[dotted] (12.5,\y) +(0,0.5)-- +(.5,0.5);
				\draw[dotted] (12.5,\y) +(0,-.5)-- +(.5,-.5);
				\draw[dotted] (.5,\y) +(0,0.5)-- +(.5,0.5);
				\draw[dotted] (.5,\y) +(0,-.5)-- +(.5,-.5);
				\foreach \x/\k in \v {
					\draw (\x,\y) +(-.5,-.5) rectangle ++(.5,.5);
					\draw (\x,\y) node{$\k$};
				}
			}

			\draw (.5,2) node[anchor=east]{1.} ;
			\draw (.5,0) node[anchor=east]{2.} ;

		\end{tikzpicture}
		\caption{\(\delta(q_i,a) = (q_j,b,R)\), that is, moving right on the
		rightmost cell.}
		\label{transition:rightmost}
    \end{subfigure}%
	\caption{Handling the transition function (edge cases).}
\end{figure}
If the head was on the leftmost cell and the transition function makes the
head move left (\ref{transition:leftmost}) then we write the colored version of the symbol designated by
the transition function to the first destination cell and then continue the
copy procedure normally. If instead the transition function makes the head move
right, we copy the first and second cell while transfering the color
(storing the position of the head) to the copy of the second cell (the copy of the first
cell is not colored).

If the head was on the last ``used'' cell and the transition function makes
the head move right (\ref{transition:rightmost}) then we need to write a blank space (\°{}) next to the
last destination
cell and put the special
``end-of-the-currently-used-portion-of-the-tape'' symbol (\e)
one cell further. If instead the transition function makes the head move left,
we transfer the color (storing the position of the head) from the last
to the penultimate working cell while copying them.

\subsection{Using a single write per cell}

We transform each cell into two adjacent cells. The left one will be used to
store the symbol and the right one to remember whether the cell has been
crossed off (that is, store the \X{} symbol).

Since all ``odd'' cells contain symbols and ``even'' cells contain cross marks,
it is not difficult to see that we can build a \TM{} that will know
which type of cell the head is currently pointing at (there is a finite number
of types of cells (2) so we can encode this in a finite number of additional
states compared to the write-twice version). Look \ref{copying:write-once} for
an example of how copying works using two cells per symbol.
\begin{figure}
    \centering
	\begin{tikzpicture}[scale=.5]
		\draw[->] (1,3.25) ++(0, 0)-- +(0,-.5) ;
		\draw[->] (2,3.25) ++(0,-2) -- +(0,-.5) ;
		\draw[->] (11,3.25) ++(0,-4) -- +(0,-.5) ;
		\draw[->] (12,3.25) ++(0,-6) -- +(0,-.5) ;
		\draw[->] (12,3.25) ++(0,-8) -- +(0,-.5) ;
		\draw[->] (3,3.25) ++(0,-10) -- +(0,-.5) ;

		\foreach \y/\v in {%
			2/{1/\Q,3/\A,5/\A,7/\Q,9/\A,11/\e,12/\0,14/\0,16/\0,18/\0,20/\0,22/\0,%
			2/\0,4/\0,6/\0,8/\0,10/\0,13/\0,15/\0,17/\0,19/\0,21/\0,23/\0},%
			0/{1/\Q,3/\A,5/\A,7/\Q,9/\A,11/\e,12/\0,14/\0,16/\0,18/\0,20/\0,22/\0,%
			2/\X,4/\0,6/\0,8/\0,10/\0,13/\0,15/\0,17/\0,19/\0,21/\0,23/\0},%
			-2/{1/\Q,3/\A,5/\A,7/\Q,9/\A,11/\e,12/\0,14/\0,16/\0,18/\0,20/\0,22/\0,%
			2/\X,4/\0,6/\0,8/\0,10/\0,13/\0,15/\0,17/\0,19/\0,21/\0,23/\0},%
			-4/{1/\Q,3/\A,5/\A,7/\Q,9/\A,11/\e,12/\0,14/\0,16/\0,18/\0,20/\0,22/\0,%
			2/\X,4/\0,6/\0,8/\0,10/\0,13/\0,15/\0,17/\0,19/\0,21/\0,23/\0},%
			-6/{1/\Q,3/\A,5/\A,7/\Q,9/\A,11/\e,12/\Q,14/\0,16/\0,18/\0,20/\0,22/\0,%
			2/\X,4/\0,6/\0,8/\0,10/\0,13/\0,15/\0,17/\0,19/\0,21/\0,23/\0},%
			-8/{1/\Q,3/\A,5/\A,7/\Q,9/\A,11/\e,12/\Q,14/\0,16/\0,18/\0,20/\0,22/\0,%
			2/\X,4/\0,6/\0,8/\0,10/\0,13/\0,15/\0,17/\0,19/\0,21/\0,23/\0},%
		}{
			\draw[dotted] (23.5,\y) +(0,0.5)-- +(.5,0.5);
			\draw[dotted] (23.5,\y) +(0,-.5)-- +(.5,-.5);
			\foreach \x/\k in \v {
				\draw (\x,\y) +(-.5,-.5) rectangle ++(.5,.5);
				\draw (\x,\y) node{$\k$};
			}
		}

		\draw (.5,2) node[anchor=east]{1.} ;
		\draw (.5,0) node[anchor=east]{2.} ;
		\draw (.5,-2) node[anchor=east]{3.} ;
		\draw (.5,-4) node[anchor=east]{4.} ;
		\draw (.5,-6) node[anchor=east]{5.} ;
		\draw (.5,-8) node[anchor=east]{6.} ;

	\end{tikzpicture}
	\caption{Copying a single cell with a write-once TM.}
	\label{copying:write-once}
\end{figure}

Symbol cells will only be written to once since we do not cross them off anymore.
``Cross-off'' cells contain the original blank symbol of the tape until the
corresponding symbol cell has been copied. When the corresponding symbol cell
is copied we write the \X{} symbol in the ``cross-off'' cell. Since a symbol
cell is copied only once, a ``cross-off'' cell is written to only once.

Again, a simple way to format the input for \(S\) to work
(interleave the input with blank symbols and add the
appropriate symbols/marks/colors) is to use special states for the
first steps of \(S\). The copy of the input can be made by crossing off the copied
cells, like in the write-twice version. Since the input cells have not been
written to yet when we start \(S\), the crossing off is the only write
operation that happens for those cells.


\subsection{Questions}
\subsubsection{Why can we not use a \TM{} with an infinite number of
tapes?\footnote{Thanks to the anonymous student who proposed this solution.}}
A \TM{} with an infinite number of tapes and an infinite number of heads
performs an infinite number of operations at each step.
To use this kind of device we should first make sure that it is equivalent to a single
tape \TM{}.
However, it is possible to use a \TM{} with an infinite number of tapes
and a finite number of heads. For example, a \TM{} with a two-dimensional
semi-infinite tape and a single head\footnote{See
\url{http://cs.stackexchange.com/q/23936}
and
\url{http://cs.stackexchange.com/q/14628}.}.

\section{Exercise 3.15.a}
A decision problem can be seen as language \(A\) using the following mapping:
\begin{enumerate}
	\item To each instance of the problem is associated a word of some alphabet
		\(\Sigma\) that encodes this instance.
	\item \(A\) is the language (a set of words) containing only
		the words that encode an instance for
		which the decision problem answer is ``yes''. Words encoding an
		instance for which the decision problem is ``no'' or words that do not
		encode an instance (garbage) are excluded from the language.
\end{enumerate}
Deciding the answer to an instance of the problem amounts to determining
whether the word encoding this instance belongs to \(A\).

A \TM{} decides a language if for each word \(w \in \Sigma^{*}\)
of the language alphabet \(\Sigma\)
it either accepts or rejects the word after a finite number of steps. A decider
will never loop forever.

\(A \cup B = \{w \st w \in A \lor w \in B\}\)
is\footnote{\(\lor = \text{``or''}\)}
the language that contains all words in \(A\) and all words in \(B\).

If we are given a \TM{} \(M_A\) that decides a language \(A\) and
a \TM{} \(M_B\) that decides a language \(B\) we can decide the
language \(A \cup B\) using \(M_{A \cup B}\) defined as follows
(solution given in the textbook):


\begin{TMachine}{``On input word \(w\):}
\item[1.] Run \(M_A\) on \(w\). If it accepts, \accept.
\item[2.] Run \(M_B\) on \(w\). If it accepts, \accept. Otherwise, \reject.''
\end{TMachine}
\(M_{A \cup B}\) accepts \(w\) if either \(M_A\) or \(M_B\) accepts it.
If both reject, \(M_{A \cup B}\) rejects.

\section{Exercise 3.16.a}

The difference from the previous exercise is that we are given \(M_A\) and
\(M_B\) that are recognizers (not deciders). A recognizer \(M\) will always stop
after a finite number of steps if run on a word that belongs to the language
\(L(M)\) (the language recognized by \(M\)).
However, if the word does not belong to \(L(M)\), \(M\) can either stop and reject or loop forever.

The solution is thus to simulate both machines \(M_A\) and \(M_B\) ``in
parallel'' (instead of in ``sequence'', like above). Solution given in the textbook:

\begin{TMachine}{``On input w:}
\item[1.] Run \(M_A\) and \(M_B\) alternately on \(w\) step by step. If either accepts,
	\accept{}. If both halt and reject, \reject{}.''
\end{TMachine}

If either \(M_A\) or \(M_B\) accepts \(w\), \(M_{A \cup B}\) accepts \(w\)
because the accepting \TM{} arrives to its
accepting state after a finite number of steps. Note that if both \(M_A\) and
\(M_B\) reject and either of them does so by looping, then \(M_{A \cup B}\)
will loop.

\section{Other exercises from 3.15 and 3.16}

You can try to solve these exercises by yourself. Here are the definitions of
the operators\footnote{\(\land = \text{``and''}\)}:
\begin{itemize}
\item[concatenation] \( A \circ B = \{ w_a w_b \st w_a \in A \land w_b \in
	B\}\), that is, the
	words that are the result of concatenating a word of \(B\) to a word of
	\(A\).
\item[star] \( A^* = \{ \epsilon \} \cup \{ w_1 \cdots w_n \st w_i \in A, n \ge
	1\}\), that is,
	words that are the result of concatenating any number of words from \(A\).
\item[complementation] \( \overline{A} = \Sigma^{*} \setminus A = \{ w \in \Sigma^{*} \st w \not \in A
	\}\), that is, words containing only symbols of the language alphabet that are not in the
	language.
\item[intersection] \( A \cap B = \{w \st w \in A \land w \in B\}\), that
	is, words that are in both \(A\) and \(B\).
\item[homomorphism] Let \(h \colon \Sigma^{*} \to \Sigma^{*}\)
	be a function such that \(h(w_1 w_2) = h(w_1) h(w_2)\) for any words
	\(w_1\) and \(w_2\). If \(A\) is
	a language, then \(h(A)\) is defined as \(\{ w \st w = h(x), x \in A\}\).
\end{itemize}

It is important to understand why complementation is not listed in Exercise 3.16.

\end{document}
