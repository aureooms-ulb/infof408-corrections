\documentclass{article}
\errorcontextlines 10000

\makeatletter
\usepackage{fontspec}
\usepackage{xunicode}
\usepackage{xltxtra}

\usepackage{fullpage}

\usepackage{hyperref}

\hypersetup{
	linktocpage  = true, %page number is the link (not title)
	colorlinks   = true, %Colours links instead of ugly boxes
	urlcolor     = darkblue, %Colour for external hyperlinks
	linkcolor    = darkblue, %Colour of internal links
	citecolor    = darkblue   %Colour of citations
}

%\hypersetup{
%	linktocpage  = true, %page number is the link (not title)
%	colorlinks   = true, %Colours links instead of ugly boxes
%	allcolors = bookColor,
%	hidelinks = true
%}

% good looking urls
\urlstyle{same}

% we use this for our references as well
\let\sref\ref
\AtBeginDocument{\renewcommand{\ref}[1]{\mbox{\autoref{#1}}}}
\usepackage[nameinlink]{cleveref}

% define colors %
\usepackage[table]{xcolor}

%\usepackage[table,dvipdfx,cmyk]{xcolor}
%\definecolor{bookColor}{cmyk}{0 ,0 ,0 ,1}
%\color{bookColor}

\definecolor{lightgray}{rgb}{.9,.9,.9}
\definecolor{darkgray}{rgb}{.4,.4,.4}
\definecolor{purple}{rgb}{0.65, 0.12, 0.82}
\definecolor{darkblue}{rgb}{0.02, 0.17, 0.40}
\usepackage[stable]{footmisc}
\usepackage{graphicx}
\usepackage{caption}
\usepackage{subcaption}
\usepackage{tikz}
\usepackage{url}
\usepackage{amsmath,amsthm}
\newcommand{\theoremname}{Theorem}
\newtheorem{theorem}{\theoremname}

\newcommand{\st}{\colon\,}
\newcommand{\TM}{TM}
\newcommand{\Atm}{A\textsubscript{TM}}
\newcommand{\HALTtm}{HALT\textsubscript{TM}}

\newcommand*\circled[1]{\tikz[baseline=(char.base)]{
            \node[shape=circle,draw,inner sep=2pt] (char) {#1};}}

% TURING MACHINE DESCRIPTIONS
\usepackage{changepage}
\newenvironment{steps}%
{%
\vspace{0.25cm}%
\begin{adjustwidth}{0.3cm}{0cm}%
\begin{description}%
}
{%
\end{description}%
\end{adjustwidth}%
\vspace{0.1cm}%
}

\newcounter{TMachine}[section]
\renewcommand{\theTMachine}{\thesection.\arabic{TMachine}}%
\newenvironment{TMachine}[1]
  {\refstepcounter{TMachine}%
   \par%
   \vspace{.5\baselineskip\@plus.2\baselineskip\@minus.2\baselineskip}% Space above
   \noindent{#1}%
   \begin{steps}}%\begin{TMachine}
  {\end{steps}%
\vspace{.5\baselineskip\@plus.2\baselineskip\@minus.2\baselineskip}% Space below
}% \end{TMachine}

\newcommand{\accept}{\emph{accept}}
\newcommand{\reject}{\emph{reject}}
\makeatother

\title{Computability and Complexity:\\Exercise Session 2 (2015-10-02)}
\author{Aurélien Ooms\footnote{aureooms@ulb.ac.be}}
\date{\today}

\begin{document}
\maketitle
\tableofcontents

\section{Exercise 4.30\footnote{Exercises from the reference book: Sipser M.,
\emph{Introduction to the Theory of Computation}, 3rd edition (2013). In the
second edition of the book, this exercise is Exercise 4.28}}

Let \(A\) be a Turing-recognizable language consisting of descriptions of
Turing machines,
\(\{\langle M_1 \rangle, \langle M_2 \rangle, \ldots \}\),
where every \(M_i\) is a decider. Prove that some decidable
language \(Q\) is not decided by any decider \(M_i\) whose description appears in
\(A\).
(Hint: You may find it helpful to consider an enumerator for \(A\).)

\subsection{Solution}

The solution is in two steps. First we construct a new language \(Q\) that is not
decided by any of the \(M_i\) using the technique of diagonalization. Second we
show how to build a decider for \(Q\) using the fact that \(A\) is
Turing-recognizable.

\ref{diagonalization} shows a diagonalization that
is similar to the ones we saw during last lecture. We build a new language \(Q\) that
disagrees with each language decided by a decider \(M_i\), that is, \(Q\) desagrees with
\(L(M_i)\) on \(w_i\). Hence, none of the \(M_i\) decides \(Q\).

\begin{table}
\centering
\caption{Building the language \(Q\). Entry \((M_i,w_j)\) is \(1\) if \(w_j \in
L(M_i)\) and \(0\) otherwise. \(w_i \in Q\) iff \(w_i \not\in L(M_i)\). For
the first four words we have that \(Q \cap \{w_1,w_2,w_3,w_4\} = \{w_2,
w_3\}\).}
\label{diagonalization}
	\begin{tabular}{c | c c c c c}
		& \(w_1\) & \(w_2\) & \(w_3\) & \(w_4\) & \(\hdots\)\\
		\hline
		\(M_1\) & \circled{1} & 1 & 1 & 1 & \(\hdots\)\\
		\(M_2\) & 0 & \circled{0} & 0 & 0 & \(\hdots\)\\
		\(M_3\) & 1 & 0 & \circled{0} & 0 & \(\hdots\)\\
		\(M_4\) & 0 & 1 & 0 & \circled{1} & \(\hdots\)\\
		\(\vdots\) & \(\vdots\) & \(\vdots\) & \(\vdots\) & \(\vdots\) & \(\ddots\)
\end{tabular}
\end{table}

We assume,
without loss of generality, that the order of the \(w_i\) is the standard
string order\footnote{%
This string order is called quasi-lexicographic order but is refered to as
``lexicographic order'' in the textbook. See
\url{https://en.wikipedia.org/wiki/Lexicographical\_order\#Quasi-lexicographic\_order}.
}, that is, first ordered by length, then lexicographically.
For a given finite alphabet \(\Sigma\), there are finitely many words of finite
length, hence there is an algorithm \(W\) that enumerates all the words of \(\Sigma^*\)
in the standard string order.

Since \(A\) is Turing-recognizable, there exists an enumerator
for \(A\), as we have shown in a previous lecture.

To prove that \(Q\) is decidable, we build the following \TM{}:

\begin{TMachine}{\(D =\) on input \(w_i\):}
\item[1.] Determine the value of \(i\) using the enumerator \(W\), that is,
enumerate all words in standard string order while maintaining a count of how
many words have been enumerated, and stop when encountering \(w_i\).
\item[2.] Enumerate the \(M_k\) of \(A\) using the enumerator for \(A\). Stop once
we have enumerated \(i\) different deciders, that is, the last decider yielded
by the enumerator is \(M_i\).
\item[3.] Simulate \(M_i\) on \(w_i\). If \(M_i\) accepts, reject. If \(M_i\) rejects, accept.
\end{TMachine}

\(D\) is a decider since:
\begin{enumerate}
\item Steps 1 and 2 execute a finite number of steps since \(i\) is finite.
\item Step 3 stops after a finite number of steps since \(M_i\) is a decider.
\end{enumerate}

\(D\) accepts \(w_i\) iff \(M_i\) rejects \(w_i\). Since \(D\) and \(M_i\) are
deciders, this is equivalent to say
that \(w_i \in L(D)\) iff \(w_i \not\in L(M_i)\), hence \(L(D) = Q\).
\(D\) is thus a decider for \(Q\) and hence \(Q\) is decidable.

\section{Scooping the Loop Snooper}
What is the following poem about?

\begin{verse}
\emph{No general procedure for bug checks will do}\footnote{%
\emph{Geoffrey K. Pullum}
\url{http://www.lel.ed.ac.uk/~gpullum/loopsnoop.html}%
}.\\
Now, I won't just assert that, I’ll prove it to you.\\
I will prove that although you might work till you drop,\\
you cannot tell if computation will stop.
\end{verse}
\begin{verse}
For imagine we have a procedure called \(P\)\\
that for specified input permits you to see\\
whether specified source code, with all of its faults,\\
defines a routine that eventually halts.
\end{verse}
\begin{verse}
You feed in your program, with suitable data,\\
and \(P\) gets to work, and a little while later\\
(in finite compute time) correctly infers\\
whether infinite looping behavior occurs.
\end{verse}
\begin{verse}
If there will be no looping, then \(P\) prints out ``Good.''\\
That means work on this input will halt, as it should.\\
But if it detects an unstoppable loop,\\
then \(P\) reports ``Bad!'' -- which means you're in the soup.
\end{verse}
\begin{verse}
Well, the truth is that \(P\) cannot possibly be,\\
because if you wrote it and gave it to me,\\
I could use it to set up a logical bind\\
that would shatter your reason and scramble your mind.
\end{verse}
\begin{verse}
Here's the trick that I’ll use -- and it's simple to do.\\
I’ll define a procedure, which I will call \(Q\),\\
that will use \(P\)'s predictions of halting success\\
to stir up a terrible logical mess.
\end{verse}
\begin{verse}
For a specified program, say \(A\), one supplies,\\
the first step of this program called \(Q\) I devise\\
is to find out from \(P\) what's the right thing to say\\
of the looping behavior of \(A\) run on \(A\).
\end{verse}
\begin{verse}
If \(P\)'s answer is ``Bad!'', \(Q\) will suddenly stop.\\
But otherwise, \(Q\) will go back to the top,\\
and start off again, looping endlessly back,\\
till the universe dies and turns frozen and black.
\end{verse}
\begin{verse}
And this program called \(Q\) wouldn't stay on the shelf;\\
I would ask it to forecast its run on itself.\\
When it reads its own source code, just what will it do?\\
What's the looping behavior of \(Q\) run on \(Q\)?
\end{verse}
\begin{verse}
If \(P\) warns of infinite loops, \(Q\) will quit;\\
yet \(P\) is supposed to speak truly of it!\\
And if \(Q\)'s going to quit, then \(P\) should say ``Good.''\\
Which makes \(Q\) start to loop! (\(P\) denied that it would.)
\end{verse}
\begin{verse}
No matter how \(P\) might perform, \(Q\) will scoop it:\\
\(Q\) uses \(P\)'s output to make \(P\) look stupid.\\
	Whatever \(P\) says, it cannot predict \(Q\):\\
\(P\) is right when it's wrong, and is false when it's true!
\end{verse}
\begin{verse}
I’ve created a paradox, neat as can be --\\
and simply by using your putative \(P\).\\
When you posited \(P\) you stepped into a snare;\\
Your assumption has led you right into my lair.
\end{verse}
\begin{verse}
So where can this argument possibly go?\\
I don't have to tell you; I'm sure you must know.\\
A \textbf{reductio}: There cannot possibly be\\
a procedure that acts like the mythical \(P\).
\end{verse}
\begin{verse}
You can never find general mechanical means\\
for predicting the acts of computing machines;\\
it's something that cannot be done. So we users\\
must find our own bugs. Our computers are losers!
\end{verse}

\subsection{Solution}

We define the following language
\begin{displaymath}
\text{\HALTtm{}} = \{ \langle M,w \rangle \st \text{\(M\) is a \TM{} and \(M\)
stops on \(w\)} \}.
\end{displaymath}
and prove the following theorem
\begin{theorem}\label{HALTtm}
\HALTtm{} is undecidable.
\end{theorem}
\begin{proof}
We assume that HALT\textsubscript{TM} is decidable and obtain a contradiction.
Suppose that \(P\) is a decider for \HALTtm{}.
On input \(\langle M, w \rangle\), where \(M\) is a \TM{} and \(w\) is a
word, \(P\) halts and accepts if \(M\) stops (accepting or rejecting) on \(w\).
Furthermore, \(P\) halts and rejects if
\(M\) loops on \(w\).
In other words, we assume that \(P\) is a \TM{}, where
\begin{displaymath}
P(\langle M, w\rangle) = \begin{cases}
	\emph{accept}&\text{if \(M\) stops on \(w\)}\\
	\emph{reject}&\text{if \(M\) loops on \(w\)}.
\end{cases}
\end{displaymath}

Now we construct a new Turing machine \(Q\) with \(P\) as a subroutine. This
new \TM{} calls \(P\) to determine what \(M\) does when the input to \(M\)
is its own
description \(\langle M \rangle\).
Once \(Q\) has determined this information, it does the opposite.
That is, it loops if \(M\) stops and stops if \(M\) loops.
The following is a description of \(Q\).

\begin{TMachine}{\(Q =\) ``On input \(\langle M \rangle\), where \(M\) is a \TM{}:}
\item[1.] Run \(P\) on input \(\langle M, \langle M \rangle \rangle\).
\item[2.] Do the opposite of what \(M\) does according to the output of
	\(P\). That is, if \(P\) accepts, loop ; and if \(P\) rejects, stop (by
	either accepting or rejecting).''
\end{TMachine}
In summary,
\begin{displaymath}
	Q(\langle M\rangle) = \begin {cases}
	\emph{stop}&\text{if \(M\) loops on \(\langle M\rangle\)}\\
	\emph{loop}&\text{if \(M\) stops on \(\langle M\rangle\).}
\end{cases}
\end{displaymath}
What happens when we run \(Q\) with its own description \(\langle Q\rangle\) as input? In that
case, we get
\begin{displaymath}
Q(\langle Q\rangle) = \begin {cases}
\emph{stop}&\text{if \(Q\) loops on \(\langle Q\rangle\)}\\
\emph{loop}&\text{if \(Q\) stops on \(\langle Q\rangle\).}
\end{cases}
\end{displaymath}
No matter what \(Q\) does, it is forced to do the opposite, which is obviously a
contradiction. We must conclude that \(Q\) cannot exist, and therefore, that
\(P\) cannot exist, that is, that \HALTtm{} is undecidable.
\end{proof}
\subsection{Questions}
\subsubsection{Can we not prove that \HALTtm{} is undecidable using the fact
that \Atm{} is undecidable?\footnote{%
Thanks to the anonymous student who suggested this solution.%
}}

\begin{theorem}\label{Atm}
\Atm{} is undecidable.
\end{theorem}

For a proof of this theorem, see the textbook or the lecture notes you have taken
on 2015-09-28. We now prove~\ref{HALTtm} using~\ref{Atm}.

\begin{proof}
By contradiction. Suppose \HALTtm{} is decidable, then,
there exists a decider \(P\) such that \(L(P) =
\text{\HALTtm{}} \). Using \(P\) we
can build a decider \(D\) for \Atm{}

\begin{TMachine}{\(D =\) ``On input \(\langle M,w \rangle\), where \(M\) is a \TM{} and \(w\) is
a word:}
	\item Run \(P\) on input \(\langle M,w \rangle\).
	\item If \(P\) rejects, that is, warns of the looping behavior of \(M\) on
		\(w\), reject.
	\item Otherwise \(M\) will stop on \(w\). We can thus simulate \(M\) on
		\(w\). If \(M\) accepts, accept. Otherwise, reject.'',
\end{TMachine}
a contradiction.
\end{proof}

\end{document}
