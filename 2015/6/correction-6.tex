\documentclass{article}
\errorcontextlines 10000

\makeatletter

\usepackage{fontspec}
\usepackage{xunicode}
\usepackage{xltxtra}

\usepackage{fullpage}
\usepackage{mleftright}
\usepackage{hhline}

\usepackage{hyperref}

\hypersetup{%
	linktocpage  = true, %page number is the link (not title)
	colorlinks   = true, %Colours links instead of ugly boxes
	urlcolor     = darkblue, %Colour for external hyperlinks
	linkcolor    = darkblue, %Colour of internal links
	citecolor    = darkblue   %Colour of citations
}

%\hypersetup{
%	linktocpage  = true, %page number is the link (not title)
%	colorlinks   = true, %Colours links instead of ugly boxes
%	allcolors = bookColor,
%	hidelinks = true
%}

% good looking urls
\urlstyle{same}

\newcommand{\theoremname}{Theorem}
\newcommand{\corollaryname}{Corollary}
\newcommand{\problemname}{Problem}
\newcommand{\conjecturename}{Conjecture}
\newcommand{\definitionname}{Definition}

% we use this for our references as well
\let\sref\ref
\AtBeginDocument{\renewcommand{\ref}[1]{\mbox{\autoref{#1}}}}
\usepackage[nameinlink]{cleveref}

% define colors %
\usepackage[table]{xcolor}

%\usepackage[table,dvipdfx,cmyk]{xcolor}
%\definecolor{bookColor}{cmyk}{0 ,0 ,0 ,1}
%\color{bookColor}

\definecolor{lightgray}{rgb}{0.9,0.9,0.9}
\definecolor{darkgray}{rgb}{0.4,0.4,0.4}
\definecolor{purple}{rgb}{0.65, 0.12, 0.82}
\definecolor{darkblue}{rgb}{0.02, 0.17, 0.40}
\usepackage[stable]{footmisc}
\usepackage{graphicx}
\usepackage{caption}
\usepackage{subcaption}
\usepackage{tikz}
\usepackage{url}
\usepackage{amsmath,amsthm,amsfonts,mathtools}
\usepackage{xfrac}


\newtheorem{theorem}{\theoremname}
\newtheorem{corollary}{\corollaryname}
\newtheorem{problem}{\problemname}
\newtheorem{conjecture}{\conjecturename}
\newtheorem{definition}{\definitionname}

% nicely spaced operators
\DeclareMathOperator{\Exists}{\exists}
\DeclareMathOperator{\Forall}{\forall}

\DeclarePairedDelimiter{\ceil}{\lceil}{\rceil}
\newcommand{\card}[1]{|#1|}

\newcommand{\st}{\colon\,}
\newcommand{\TM}{TM}
\newcommand{\Atm}{A\textsubscript{TM}}
\newcommand{\HALTtm}{HALT\textsubscript{TM}}

\newcommand{\N}{\mathbb{N}}
\newcommand{\nth}[1]{#1^{\text{th}}}

\newcommand*\circled[1]{\tikz[baseline=(char.base)]{
            \node[shape=circle,draw,inner sep=2pt] (char) {#1};}}



% TURING MACHINE DESCRIPTIONS
\usepackage{changepage}
\newenvironment{steps}%
{%
\vspace{0.25cm}%
\begin{adjustwidth}{0.3cm}{0cm}%
\begin{description}%
}
{%
\end{description}%
\end{adjustwidth}%
\vspace{0.1cm}%
}

\newcounter{TMachine}[section]
\renewcommand{\theTMachine}{\thesection.\arabic{TMachine}}%
\newenvironment{TMachine}[1]
  {\refstepcounter{TMachine}%
   \par%
   \vspace{.5\baselineskip\@plus.2\baselineskip\@minus.2\baselineskip}% Space above
   \noindent{#1}%
   \begin{steps}}%\begin{TMachine}
  {\end{steps}%
\vspace{.5\baselineskip\@plus.2\baselineskip\@minus.2\baselineskip}% Space below
}% \end{TMachine}

\newcommand{\accept}{\emph{accept}}
\newcommand{\reject}{\emph{reject}}

\makeatother

\title{Computability and Complexity:\\Exercise Session 6 (2015-11-13)}
\author{Aur√©lien Ooms\footnote{aureooms@ulb.ac.be}}
\date{\today}

\begin{document}
\maketitle
\tableofcontents

\section{\texorpdfstring{UHAMPATH is NP-complete\footnote{%
Theorem 7.55 from the reference book: Sipser M.,
\emph{Introduction to the Theory of Computation}, 3rd edition
(2013).}}{UHAMPATH is NP-complete}}

Last lecture we showed that
\begin{theorem}
	HAMPATH is NP-complete.
\end{theorem}
We now want to show that the undirected version of HAMPATH is NP-complete too
\begin{definition}
	UHAMPATH \(= \{\langle G, s, t\rangle \st G\) is an undirected
				graph and has an hamiltonian path from vertex \(s\) to vertex
	\(t\}\).
\end{definition}
We prove the following
\begin{theorem}
	UHAMPATH is NP-complete.
\end{theorem}
\begin{proof}
	Clearly, UHAMPATH is in NP. For any instance \(\langle G,s,t\rangle\)
	any sequence of vertices that is a
	hamiltonian path from \(s\) to \(t\) in \(G\) can be used as a certificate
	of polynomial size.
	Given an instance \(\langle G, s, t \rangle\) of the HAMPATH problem, we
	build an instance \(\langle G', s^{out}, t^{in}\rangle\) of the UHAMPATH
	problem as follows. Start with an empty undirected graph \(G'\). For the
	vertices \(s\) and \(t\) of \(G\) add the vertices \(s^{out}\) and
	\(t^{in}\) to \(G'\). For each vertex \(v\) other than \(s\) and \(t\) add
	vertices \(v^{in}, v^{mid}\) and \(v^{out}\) to \(G'\). For each triple
	\(v^{in},v^{mid},v^{out}\) of \(G'\) add the undirected edges \(\{v^{in},
	v^{mid}\}\) and \(\{v^{mid},v^{out}\}\) to \(G'\).
	For each directed
	edge \((u,v)\) with \(u \neq t\) and \(v \neq s\) of \(G\) add an
	undirected
	edge \(\{u^{out},v^{in}\}\) to \(G'\).

	Now we prove that \(\langle G, s, t \rangle \in\) HAMPATH if and only if
	\(\langle G', s^{out}, t^{in}\rangle \in\) UHAMPATH. A hamiltonian path from \(s\) to
	\(t\) in \(G\) has the following form
	\begin{displaymath}
		s, u_{i_1}, u_{i_2}, \ldots, u_{i_{n-2}}, t
	\end{displaymath}
	which corresponds to the hamiltonian path
	\begin{displaymath}
		s^{out}, u^{in}_{i_1}, u^{mid}_{i_1}, u^{out}_{i_1}, u^{in}_{i_2},
		u^{mid}_{i_2}, u^{out}_{i_2}, \ldots, u^{in}_{i_{n-2}}, u^{mid}_{i_{n-2}},
		u^{out}_{i_{n-2}}, t^{in}
	\end{displaymath}
	in \(G'\). For the other direction of the equivalence we show that a
	hamiltonian path from \(s^{out}\) to \(t^{in}\) in \(G'\) can only have the
	form given above. Such a hamiltonian path must start with \(s^{out}\) and
	since there is no \(s^{mid}\) in \(G'\) we are only able to reach a vertex
	of the type \(u^{in}\). Once in \(u^{in}\) we can only go to \(u^{mid}\).
	This is because the only vertices incident to \(u^{mid}\) are \(u^{in}\) and
	\(u^{out}\). If we do not go to \(u^{mid}\) just after \(u^{in}\),
	the only way to reach \(u^{mid}\) will be through \(u^{out}\) and there
	will be then no way to escape from \(u^{mid}\). Once we are in \(u^{mid}\)
	we continue to \(u^{out}\). We are now in the same configuration as the one
	we started with, except that we removed vertices
	\(s^{out},u^{in},u^{mid}\). To visit all vertices, we must repeat this
	scheme until there is only two vertices left, that is, \(u^{out}_{n-2}\)
	and \(t^{in}\). Note that the complexity of this reduction is linear in the
	size of the input graph \(G\).
\end{proof}

\section{\texorpdfstring{SUBSET-SUM is NP-complete\footnote{%
Theorem 7.56 from the reference book: Sipser M.,
\emph{Introduction to the Theory of Computation}, 3rd edition
(2013).}}{SUBSET-SUM is NP-complete}}
Let us define the language SUBSET-SUM
\begin{definition}
	SUBSET-SUM \(= \{\langle S, t\rangle \st\)
	\(S = \{x_1,x_2,\ldots,x_n\} \subset \N\),
	\(t \in \N\) and there exists \(X \subseteq S\) such that
	\(\sum_{x \in X} x = t\)
	\(\}\)
\end{definition}
It is easy to see that SUBSET-SUM \(\in\) NP since we can use \(X\) as a
certificate of polynomial size.
We are left to prove that all problems in NP reduce to SUBSET-SUM in polynomial
time. We do this by reducing 3SAT to SUBSET-SUM in polynomial time.
\begin{theorem}
	3SAT \(\le_P\) SUBSET-SUM
\end{theorem}
\begin{proof}
	Given a 3-CNF formula \(\Phi\) with \(n\) variables
	\(\{x_1,x_2,\ldots,x_n\}\) and \(m\) clauses \(\{c_1,c_2,\ldots,c_m\}\)
	we build the SUBSET-SUM instance \(f(\langle \Phi \rangle) = \langle
	S,t\rangle\) with set \(S =
	\{y_1,z_1,y_2,z_2,\ldots,y_n,z_n,g_1,h_1,g_2,h_2,\ldots,g_m,h_m\}\) and
	\(t = 11\ldots133\ldots3\) as in
	\ref{subsetsum}. For the sake of the explanation, we consider that each of
	these numbers is composed of exactly \(n+m\) digits, including leading
	zeros.

	For each variable \(x_i\) we define the two numbers
	\(y_i\) and \(z_i\). The first \(n\) digits of \(y_i\) and \(z_i\) are
	zeros except for the \(\nth{i}\) digit which is set to \(1\). The first
	\(n\) digits of \(g_j\) and \(h_j\) are zeros. The first
	\(n\) digits of \(t\) are ones so that if \(X\) exists it must contain
	exactly one of \(y_i\) and \(z_i\) for each \(i\).
	The \(\nth{(n+j)}\) digit of \(y_i\) is set to \(1\) if the literal \(x_i\)
	appears in clause \(c_j\), it is set to \(0\) otherwise.
	The \(\nth{(n+j)}\) digit of \(z_i\) is set to \(1\) if the literal
	\(\overline{x_i}\)
	appears in clause \(c_j\), it is set to \(0\) otherwise. The last \(m\)
	digits of \(g_j\) and \(h_j\) are zeros except for the \(\nth{(n+j)}\) digit
	which is set to \(1\). The last \(m\) digits of \(t\) are set to \(3\).

	We want to prove that \(\langle \Phi \rangle \in \text{3SAT} \iff \langle
	S,t\rangle \in \text{SUBSET-SUM}\).
	If \(\Phi\) is satisfiable, then there
	exists an assignment \(a = (a_1, a_2,\ldots,a_n) \in \{0,1\}^n\) on the
	variables \(x_1,x_2,\ldots,x_n\) such that each clause \(c_j\) of \(\Phi\)
	is satisfied. This means that at least one literal of \(c_j\) is true. We
	build a certificate \(X\) from this assigment by including \(y_i\) if and
	only if \(a_i = 1\). We include \(z_i\) if and only if \(a_i = 0\).
	At this point of the construction of \(X\), the first \(n\) digits of the
	sum of the elements of \(X\) are ones, and each \(\nth{(n+j)}\) digit of
	the same sum is between \(1\) and \(3\). The former is true because we
	included exactly one of \(y_i\) and \(z_i\) for each \(i \in
	\{1,2,\ldots,n\}\) and the latter is true because each clause contains at
	most three literals and, since each clause \(c_j\) is satisfied by
	assignment \(a\), for each \(j \in \{1,2,\ldots,m\}\) at least one of the
	included numbers as a \(1\) at the \(\nth{(n+j)}\) position.
	We then include as many of \(g_j\) and \(h_j\) are necessary to reach the
	target sum \(t\).

	For the other direction, consider a certificate \(X\) for the instance
	\(\langle S,t\rangle\). By construction, this certificate must include
	exactly one of \(y_i\) and \(z_i\). We build a satisfying assignment \(a =
	(a_1,a_2,\ldots,a_n) \in \{0,1\}^n\) for \(\Phi\) as follows. If \(y_i \in
	X\), set \(a_i = 1\). Otherwise set \(a_i = 0\). For \(\sum_{x \in X} x\)
	to be equal to \(t\), it must be that for each \(j \in \{1,2,\ldots,m\}\)
	at least one of the included \(y_i\) or \(z_i\) has a \(0\) at position
	\(\nth{(n+j)}\) otherwise the \(\nth{(n+j)}\) digit of the sum can never
	reach \(3\). This means that for each \(c_j\), at least one literal is set
	to true by assignment \(a\). \(a\) is thus a satisfying assignment for
	\(\Phi\).

	Note that a carry never occurs when computing the sum of a subset of \(S\)
	because the digits of the numbers of \(S\) are zeros or ones and there are
	at most five ones when considering the \(\nth{i}\) digit of all numbers of
	\(S\). The complexity of this reduction is quadratic in the number of
	variables and clauses.
\end{proof}

\begin{table}
	\centering
	\begin{tabular}{|c|*{6}{c}||*{6}{c}|}
	\hline
	& \(x_1\) & \(x_2\) & \(\cdots\) & \(x_i\) & \(\cdots\) & \(x_n\) & \(c_1\) & \(c_2\)
	& \(\cdots\) & \(c_j\) & \(\cdots\) & \(c_m\)\\
	\hline

	\(y_1\) & \(1\) & \(0\) & \(\cdots\) & \(0\) & \(\cdots\) & \(0\) & \(0\)
	& \(0\) & \(\cdots\) & \(1\) & \(\cdots\) & \(1\)\\
	\(z_1\) & \(1\) & \(0\) & \(\cdots\) & \(0\) & \(\cdots\) & \(0\) & \(0\)
	& \(1\) & \(\cdots\) & \(0\) & \(\cdots\) & \(1\)\\

	\(y_2\) & \(0\) & \(1\) & \(\cdots\) & \(0\) & \(\cdots\) & \(0\) & \(1\)
	& \(1\) & \(\cdots\) & \(0\) & \(\cdots\) & \(0\)\\
	\(z_2\) & \(0\) & \(1\) & \(\cdots\) & \(0\) & \(\cdots\) & \(0\) & \(0\)
	& \(0\) & \(\cdots\) & \(0\) & \(\cdots\) & \(1\)\\

	\(\vdots\) & \(\vdots\) & \(\vdots\) & \(\ddots\) & \(\vdots\) & \(\ddots\)
	& \(\vdots\) & \(\vdots\) & \(\vdots\) & \(\ddots\) & \(\vdots\) &
	\(\ddots\) & \(\vdots\)\\

	\(y_i\) & \(0\) & \(0\) & \(\cdots\) & \(1\) & \(\cdots\) & \(0\) & \(0\)
	& \(0\) & \(\cdots\) & \(0\) & \(\cdots\) & \(0\)\\
	\(z_i\) & \(0\) & \(0\) & \(\cdots\) & \(1\) & \(\cdots\) & \(0\) & \(1\)
	& \(0\) & \(\cdots\) & \(1\) & \(\cdots\) & \(0\)\\

	\(\vdots\) & \(\vdots\) & \(\vdots\) & \(\ddots\) & \(\vdots\) & \(\ddots\)
	& \(\vdots\) & \(\vdots\) & \(\vdots\) & \(\ddots\) & \(\vdots\) &
	\(\ddots\) & \(\vdots\)\\

	\(y_n\) & \(0\) & \(0\) & \(\cdots\) & \(0\) & \(\cdots\) & \(1\) & \(0\)
	& \(1\) & \(\cdots\) & \(0\) & \(\cdots\) & \(0\)\\
	\(z_n\) & \(0\) & \(0\) & \(\cdots\) & \(0\) & \(\cdots\) & \(1\) & \(0\)
	& \(0\) & \(\cdots\) & \(0\) & \(\cdots\) & \(0\)\\
	\hhline{|=|*{6}{=}||*{6}{=}|}
	\(g_1\) & \(0\) & \(0\) & \(\cdots\) & \(0\) & \(\cdots\) & \(0\) & \(1\)
	& \(0\) & \(\cdots\) & \(0\) & \(\cdots\) & \(0\)\\
	\(h_1\) & \(0\) & \(0\) & \(\cdots\) & \(0\) & \(\cdots\) & \(0\) & \(1\)
	& \(0\) & \(\cdots\) & \(0\) & \(\cdots\) & \(0\)\\

	\(g_2\) & \(0\) & \(0\) & \(\cdots\) & \(0\) & \(\cdots\) & \(0\) & \(0\)
	& \(1\) & \(\cdots\) & \(0\) & \(\cdots\) & \(0\)\\
	\(h_2\) & \(0\) & \(0\) & \(\cdots\) & \(0\) & \(\cdots\) & \(0\) & \(0\)
	& \(1\) & \(\cdots\) & \(0\) & \(\cdots\) & \(0\)\\

	\(\vdots\) & \(\vdots\) & \(\vdots\) & \(\ddots\) & \(\vdots\) & \(\ddots\)
	& \(\vdots\) & \(\vdots\) & \(\vdots\) & \(\ddots\) & \(\vdots\) &
	\(\ddots\) & \(\vdots\)\\

	\(g_i\) & \(0\) & \(0\) & \(\cdots\) & \(0\) & \(\cdots\) & \(0\) & \(0\)
	& \(0\) & \(\cdots\) & \(1\) & \(\cdots\) & \(0\)\\
	\(h_i\) & \(0\) & \(0\) & \(\cdots\) & \(0\) & \(\cdots\) & \(0\) & \(0\)
	& \(0\) & \(\cdots\) & \(1\) & \(\cdots\) & \(0\)\\

	\(\vdots\) & \(\vdots\) & \(\vdots\) & \(\ddots\) & \(\vdots\) & \(\ddots\)
	& \(\vdots\) & \(\vdots\) & \(\vdots\) & \(\ddots\) & \(\vdots\) &
	\(\ddots\) & \(\vdots\)\\

	\(g_m\) & \(0\) & \(0\) & \(\cdots\) & \(0\) & \(\cdots\) & \(0\) & \(0\)
	& \(0\) & \(\cdots\) & \(0\) & \(\cdots\) & \(1\)\\
	\(h_m\) & \(0\) & \(0\) & \(\cdots\) & \(0\) & \(\cdots\) & \(0\) & \(0\)
	& \(0\) & \(\cdots\) & \(0\) & \(\cdots\) & \(1\)\\
	\hhline{|=|*{6}{=}||*{6}{=}|}
	\(t\) & \(1\) & \(1\) & \(\cdots\) & \(1\) & \(\cdots\) & \(1\) & \(3\)
	& \(3\) & \(\cdots\) & \(3\) & \(\cdots\) & \(3\)\\
	\hline
\end{tabular}
\caption{Construction of \(S\) and \(t\) for \(\Phi =
	(x_2\lor\overline{x_i}\lor\ldots) \land
	(\overline{x_1}\lor x_2 \lor x_n) \land \cdots \land
(x_1\lor\overline{x_i}\lor\ldots) \land \cdots \land (x_1 \lor \overline{x_1} \lor \overline{x_2} )\).}
\label{subsetsum}
\end{table}


\section{\texorpdfstring{Exercise 7.18\footnote{%
Exercises from the reference book: Sipser M.,
\emph{Introduction to the Theory of Computation}, 3rd edition
(2013).}}{Exercise 7.18}}

We want to prove that
\begin{theorem}
P \(=\) NP \(\implies\) P \(\setminus \{\emptyset, \Sigma^*\} =\) NP-complete.
\end{theorem}
\begin{proof}
	Indeed \(\emptyset\) is not NP-complete. Suppose it was, then for each
	\(A \in\) NP, there would
	exist some computable function \(f\) such that \(w \in A \iff f(w) \in
	\emptyset\). However, whatever \(f\) is, for all \(w \in \Sigma^*\), \(f(w) \not\in
\emptyset\) and so it is impossible to map ``yes'' instances of \(A\) to
``yes'' instances of \(\emptyset\). Languages that are not \(\emptyset\)
contain at least one ``yes'' instance. By a similar argument, \(\Sigma^*\) is
not NP-complete. In that case, it is impossible to map ``no'' instances.

If P \(=\) NP then for each pair of languages \(A, B \in\) NP, where \(B\) is
neither \(\emptyset\) nor \(\Sigma^*\), we can design a computable function
\(f_{A \le_P B}\) that runs in polynomial time so that \(w \in A \iff f_{A
\le_P B}(w) \in B\). Let \(x \in B\) and \(z \not\in B\) and \(M_A\) be a
Turing-machine that decides \(A\) in polynomial time
\begin{TMachine}{\(f_{A \le_P B} =\) on input \(w\)}
\item[1.] Run \(M_A\) on \(w\).
\item[2.] If \(w \in A\) write \(x\) on the tape and halt. Otherwise, write
\(z\) on the tape and halt.
\end{TMachine}
Note that \(x\) and \(z\) do not depend on \(w\) and hence, their size does not
depend on the input size. The whole computation runs thus in polynomial time.

\end{proof}
\end{document}
